* About
:PROPERTIES:
:ID:       20ff1c28-cfc6-4280-8501-83314fee390d
:END:
This repo includes the custom PCBs and PC control software necessary
to build and operate a 6GHz FMCW radar. It also includes a number of
other useful additions, such as RF and SPICE simulations (in progress)
as well as CAD designs for the horn antennas and PCB cases.

The project is a fork of [[https://github.com/Ttl/fmcw3][Henrik's excellent design]]. Although I've made
a number of [[id:8f78da8c-ec0c-40f3-9b8b-6c1af11f4bb2][significant changes]], most of the main PCB (as of this
writing) is still identical to Henrik's. Despite the fact that Henrik
deserves a large share of the credit for this project, he is in no way
affiliated with this fork.

This project is still in its early stages. In particular, there are a
number of hardware issues that make this version inferior to
Henrik's. These will be fixed in a future version, but I would hold
off building this version until these issues are fixed.

* TODO Capabilites
Briefly mention the radar's capabilities.

* TODO Installation
* TODO Additional hardware
* Modifications from the original
:PROPERTIES:
:ID:       8f78da8c-ec0c-40f3-9b8b-6c1af11f4bb2
:END:
The FPGA code has been completely rewritten and expanded so that
nearly all data processing is now done on the FPGA. This was done
while keeping the same FPGA chip. This allows the fully processed
output to be plotted in realtime and simplifies the data processing
requirements of the host PC code. The FPGA code also includes
automated tests and, in some cases, formal verification.

Because the FPGA responsibilities were expanded, the PC software had
new requirements and had to be rewritten as well. The software is
multithreaded and separates out the task of acquiring data from
plotting it. Additionally, the software and FPGA gateware have been
designed to make the radar easier to debug. For instance, data
processing can be shared in any way between the software and FPGA,
which makes gateware bugs easier to isolate. It's also possible to
request data from the FPGA in any intermediate form.

I completely redid the PCB layout because of the need for a new power
amplifier (note that this introduced at least [[id:0246fbe1-ba4a-4bf6-b551-a896264dea3a][one significant issue]]).

I've added horn antennas that can be built by anyone with access to a
3D printer. There's also a 3D-printable mount to hold the entire
structure.

I've greatly expanded the documentation, which should be useful to
anyone who wants to understand how the radar works in detail.

I've added a number of RF simulations (using [[https://openems.de/start/][OpenEMS]]) and spice
simulations (using [[http://ngspice.sourceforge.net/][Ngspice]]).

Finally, I have plans to multiplex 8 receiver antennas across the 2
receiver channels for better angular resolution. The PCB has already
been built (though is untested), but I haven't yet had the time to
write the FPGA code and software to support it.

* Issues and To-Do
:PROPERTIES:
:ID:       0246fbe1-ba4a-4bf6-b551-a896264dea3a
:END:
The power circuitry that was added to accommodate a new power
amplifier (the original was deprecated) adds noise that shows up in
the final output. Because of this problem, if you're able to track
down the old power amplifier I'd recommend using Henrik's design
instead. My FPGA code and software (at least for now) should be fully
compatible with the original hardware. I intend to fix this problem in
a future version.

I'm currently working on a number of RF simulations that will
eventually lead to a replacement of some of the RF PCB
layout. Currently, I have very limited information on whether these
parts of the PCB actually work the way they should. Areas of focus
include transmission line characteristic impedance, transmission line
to SMA transitions, and replacement of discrete components such as
couplers, attenuators, etc. with the equivalent components etched
directly onto the PCB. Once the RF simulations are complete, I'd like
to prototype these before actually building them into the
radar. Unfortunately, I don't yet have the proper testing equipment
for this (building a VNA is the next project...).

* Contributing
Pull requests and issues welcome. I'm open to suggestions for hardware
modification, although may or may not be able to merge those commits
depending on whether I can test the change.

* TODO Operation
Link blog post.

** streaming raw data
We'll focus on a single channel, since it doesn't seem worth it to try
to get the raw data from both channels simultaneously. The ADC outputs
a 12-bit sample every 25ns (rate of 40MHz). The FT2232H can stream
data to the host at 480Mbps (1 byte at 60MHz). Superficially, this
seems convenient since these data rates are the same. However, the
streaming data requires some overhead bits to avoid transmission
errors.

On the other hand -- in the worst case -- we would have to store a
full sequence before sending it to the host. To have enough data for a
1024-point FFT (as is done on the FPGA), we would need 20 times this
or 20,480 raw samples (FFT is performed on downsampled data). At
12-bits per sample, this amounts to a total of 245,760 bits of data to
store on the FPGA. The onboard FPGA has 25 36kb RAM blocks (or
equivalently, 50 18kb RAM blocks). Storing all our data would require
7 of these. We can do better than this by streaming data to the host
while capturing it. But, while we don't have to store our overhead
bits, we still do have to send them.

Imagine we only need to send each transmission once and we just need 1
byte for the header and tail combined (a nibble for each) to ensure
reads are aligned. We also need a counter to ensure we don't miss any
whole packets (whether or not this will be necessary remains to be
seen and I guess depends on how well the OS/FTDI handle the
communication). 1 byte for the counter only allows us 256 packets and
is not nearly enought. 2 bytes permits 65,536 packets and is
plenty. This leaves 5 bytes of data in each packet. Because of the
overhead, we now need to send 393,216 bits. Since we capture and send
at the same bit rate, when all 245,760 bits are sent, we will be left
with 147,456 bits. However, 3/8 of this is overhead and doesn't need
to be stored. This leaves us with a max storage requirement of 92,160
bits. This would require just 3 BRAMs, which is very manageable.

* TODO Attribution
+ Henrik, of course (see [[id:20ff1c28-cfc6-4280-8501-83314fee390d][About]]).
+ An additional thanks to AlexBdx for finding a way to 3D print horn
  antennas.
